{
  "components": {
    "schemas": {
      "elephant.repository.ACLEntry": {
        "properties": {
          "permissions": {
            "description": "Permissions given to the grantee.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "uri": {
            "description": "URI that identifies the party that's granted access.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.AttachmentDetails": {
        "properties": {
          "content_type": {
            "description": "ContentType is the MIME type of the object.",
            "type": "string"
          },
          "document": {
            "description": "Document is the UUID of the document the object is attached to.",
            "type": "string"
          },
          "download_link": {
            "description": "DownloadLink that can be used to fetch the object contents, if requested.",
            "type": "string"
          },
          "filename": {
            "description": "Filename is the name of the file the object represents.",
            "type": "string"
          },
          "name": {
            "description": "Name of the attachment.",
            "type": "string"
          },
          "version": {
            "description": "Version of the attachment.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.AttachmentRef": {
        "properties": {
          "name": {
            "description": "Name of the attachment.",
            "type": "string"
          },
          "version": {
            "description": "Version is the current version of the attachment.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.BulkGetItem": {
        "properties": {
          "document": {
            "$ref": "#/components/schemas/newsdoc.Document"
          },
          "version": {
            "description": "Version is the version of the returned document.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.BulkGetReference": {
        "properties": {
          "uuid": {
            "description": "UUID of the document to get.",
            "type": "string"
          },
          "version": {
            "description": "Version to get, omit to get latest.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.BulkGetRequest": {
        "properties": {
          "documents": {
            "description": "Documents to get.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.BulkGetReference"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.BulkGetResponse": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.BulkGetItem"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.BulkUpdateRequest": {
        "properties": {
          "updates": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.UpdateRequest"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.BulkUpdateResponse": {
        "properties": {
          "updates": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.UpdateResponse"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.ConfigureTypeRequest": {
        "properties": {
          "configuration": {
            "$ref": "#/components/schemas/elephant.repository.TypeConfiguration"
          },
          "type": {
            "description": "Type to configure.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.ConfigureTypeResponse": {
        "type": "object"
      },
      "elephant.repository.CreateStatusRuleRequest": {
        "properties": {
          "rule": {
            "$ref": "#/components/schemas/elephant.repository.StatusRule"
          }
        },
        "type": "object"
      },
      "elephant.repository.CreateStatusRuleResponse": {
        "type": "object"
      },
      "elephant.repository.CreateUploadRequest": {
        "properties": {
          "content_type": {
            "description": "ContentType is the type of the file as a mimetype.",
            "type": "string"
          },
          "meta": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Meta can be used to set arbitrary key-value data on an upload.",
            "type": "object"
          },
          "name": {
            "description": "Name of the uploaded file, this should be the basename of the file.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.CreateUploadResponse": {
        "properties": {
          "id": {
            "description": "ID of the created upload.",
            "type": "string"
          },
          "url": {
            "description": "URL to PUT the object content to.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.DeleteDocumentRequest": {
        "properties": {
          "if_match": {
            "description": "IfMatch is used for optimistic locks. Set to the version that you require to be the current one for the delete to be performed.",
            "type": "integer"
          },
          "lockToken": {
            "description": "LockToken is used for explicit pessimistic locking.",
            "type": "string"
          },
          "meta": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Meta data to include with the delete record.",
            "type": "object"
          },
          "uuid": {
            "description": "UUID of the document to delete.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.DeleteDocumentResponse": {
        "type": "object"
      },
      "elephant.repository.DeleteMetricKindRequest": {
        "properties": {
          "name": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.DeleteMetricKindResponse": {
        "type": "object"
      },
      "elephant.repository.DeleteRecord": {
        "properties": {
          "created": {
            "description": "Creation time for the delete record, as an RFC3339 timestamp.",
            "type": "string"
          },
          "creator": {
            "description": "Creator of the delete record.",
            "type": "string"
          },
          "finalised": {
            "description": "Finalised is the time, as an RFC3339 timestamp, that the document finished deleting. Empty if the delete is in progress.",
            "type": "string"
          },
          "id": {
            "description": "ID of the delete record.",
            "type": "integer"
          },
          "language": {
            "description": "Language that the document was in.",
            "type": "string"
          },
          "meta": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Meta data included with the delete record.",
            "type": "object"
          },
          "purged": {
            "description": "Purged is the time, as an RFC3339 timestamp, all archived data for the document was purged. Empty if the document hasn't been purged.",
            "type": "string"
          },
          "type": {
            "description": "Type of the document.",
            "type": "string"
          },
          "uri": {
            "description": "URI of the document.",
            "type": "string"
          },
          "uuid": {
            "description": "UUID of the document.",
            "type": "string"
          },
          "version": {
            "description": "Version that the document had at the time of restore.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.DeleteStatusRuleRequest": {
        "properties": {
          "name": {
            "type": "string"
          },
          "type": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.DeleteStatusRuleResponse": {
        "type": "object"
      },
      "elephant.repository.DeleteWorkflowRequest": {
        "properties": {
          "type": {
            "description": "Type of the document to remove the workflow for.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.DeleteWorkflowResponse": {
        "type": "object"
      },
      "elephant.repository.Deprecation": {
        "properties": {
          "enforced": {
            "type": "boolean"
          },
          "label": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.DocumentFilter": {
        "properties": {
          "and": {
            "description": "And filters that all must be true.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.DocumentFilter"
            },
            "type": "array"
          },
          "expression": {
            "description": "Expression used to extract values from the document.",
            "type": "string"
          },
          "operator": {
            "$ref": "#/components/schemas/elephant.repository.FilterOperator"
          },
          "or": {
            "description": "Or filters of which at least one must be true.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.DocumentFilter"
            },
            "type": "array"
          },
          "values": {
            "description": "Values to compare to the extracted values.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.FilterValues"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.DocumentMatch": {
        "properties": {
          "document": {
            "$ref": "#/components/schemas/newsdoc.Document"
          },
          "meta": {
            "$ref": "#/components/schemas/elephant.repository.DocumentMeta"
          },
          "uuid": {
            "description": "UUID of the document.",
            "type": "string"
          },
          "version": {
            "description": "Version of the document.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.DocumentMeta": {
        "properties": {
          "acl": {
            "description": "ACL is an ACL list controlling access to the document.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.ACLEntry"
            },
            "type": "array"
          },
          "attachments": {
            "description": "Attachments are the names of the attached objects (files) for a document.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.AttachmentRef"
            },
            "type": "array"
          },
          "created": {
            "description": "Created timestamp is the RFC3339 timestamp for when the document was created.",
            "type": "string"
          },
          "creator_uri": {
            "description": "CreatorURI is the identity of the party that created the document.",
            "type": "string"
          },
          "current_version": {
            "description": "CurrentVersion is the last written version of the document.",
            "type": "integer"
          },
          "heads": {
            "additionalProperties": {
              "$ref": "#/components/schemas/elephant.repository.Status"
            },
            "description": "Heads are the last statuses.",
            "type": "object"
          },
          "is_meta_document": {
            "description": "IsMetaDocument is true if the document is a meta document.",
            "type": "boolean"
          },
          "lock": {
            "$ref": "#/components/schemas/elephant.repository.Lock"
          },
          "main_document": {
            "description": "MainDocument is the UUID of the main document if this is a meta document.",
            "type": "string"
          },
          "modified": {
            "description": "Modified timestamp is the RFC3339 timestamp for the last change that affected the document.",
            "type": "string"
          },
          "nonce": {
            "description": "Nonce is the unique nonce for this document. If the document is deleted and recreated with the same ID it will still have a unique nonce.",
            "type": "string"
          },
          "updater_uri": {
            "description": "UpdaterURI is the identity of the party that last updated the document.",
            "type": "string"
          },
          "workflow_checkpoint": {
            "description": "WorkflowCheckpoint that the document reached most recently.",
            "type": "string"
          },
          "workflow_state": {
            "description": "WorkflowState that the document is in.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.DocumentMetrics": {
        "properties": {
          "metrics": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.Metric"
            },
            "type": "array"
          },
          "uuid": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.DocumentStatuses": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.Status"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.DocumentVersion": {
        "properties": {
          "created": {
            "description": "Created timestamp is the RFC3339 timestamp for when the version was created.",
            "type": "string"
          },
          "creator": {
            "description": "Creator of the version.",
            "type": "string"
          },
          "meta": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Meta data to for the document version.",
            "type": "object"
          },
          "statuses": {
            "additionalProperties": {
              "$ref": "#/components/schemas/elephant.repository.DocumentStatuses"
            },
            "description": "Statuses that have been set for the document version.",
            "type": "object"
          },
          "version": {
            "description": "Version of the document.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.DocumentWorkflow": {
        "properties": {
          "checkpoint": {
            "description": "Checkpoint is the status that should be used as the state checkpoint.",
            "type": "string"
          },
          "negative_checkpoint": {
            "description": "NegativeCheckpoint is the state that should be used when the checkpoint status is set using a negative version.",
            "type": "string"
          },
          "step_zero": {
            "description": "StepZero is the step that the state begins in, or reverts to after a checkpoint.",
            "type": "string"
          },
          "steps": {
            "description": "Steps are the names of statuses that should be used as steps between checkpoints.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.EntityRef": {
        "properties": {
          "index": {
            "description": "Index is the position of the entity in an array, where applicable.",
            "type": "integer"
          },
          "kind": {
            "description": "Kind is the block type, one of \"link\", \"meta\", or \"content\".",
            "type": "string"
          },
          "name": {
            "description": "Name is the name of the entity, where applicable.",
            "type": "string"
          },
          "ref_type": {
            "description": "RefType is type of entity that's referenced, one of \"block\", \"property\", \"attribute\", \"data attribute\", or \"parameter.\"",
            "type": "string"
          },
          "rel": {
            "description": "Rel is the relationship for the entity, where applicable.",
            "type": "string"
          },
          "type": {
            "description": "Type is the type of the entity, where applicable.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.EventlogItem": {
        "properties": {
          "acl": {
            "description": "Acl entry, if it was an \"acl\" event.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.ACLEntry"
            },
            "type": "array"
          },
          "attached_objects": {
            "description": "AttachedObjects contains the object names, f.ex. \"image\" or \"audio\", when when objects (files) were attached together with a document update.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "delete_record_id": {
            "description": "DeleteRecordId is the ID of the delete record if this was a delete event.",
            "type": "integer"
          },
          "detached_objects": {
            "description": "DetachedObjects contains the object names, f.ex. \"image\" or \"audio\", when when objects (files) were detached in a document update.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "document_nonce": {
            "description": "DocumentNonce is the unique nonce for this document. If the document is deleted and recreated with the same ID it will still have a unique nonce.",
            "type": "string"
          },
          "event": {
            "description": "Event type, one of: \"document\", \"status\", \"acl\", \"delete_document\", \"restore_finished\", \"workflow\".",
            "type": "string"
          },
          "id": {
            "description": "Id of the event.",
            "type": "integer"
          },
          "language": {
            "description": "Language of the affected document.",
            "type": "string"
          },
          "main_document": {
            "description": "MainDocument UUID if the document is a metadata document.",
            "type": "string"
          },
          "main_document_type": {
            "description": "MainDocumentType is the type of the main document if the document is a metadata document.",
            "type": "string"
          },
          "old_language": {
            "description": "OldLanguage of the document if the document changed language.",
            "type": "string"
          },
          "status": {
            "description": "Status that was affected, if it was a \"status\" event.",
            "type": "string"
          },
          "status_id": {
            "description": "StatusId is the ID of the created status.",
            "type": "integer"
          },
          "system_state": {
            "description": "SystemState is set to \"restoring\" if this event was generated from a restore operation. If the event wasn't generated by a special operation it is left empty.",
            "type": "string"
          },
          "timespans": {
            "description": "Timespans are the timespans that were extracted from a document update and from the assignment if this document is a deliverable. Only present for \"document\" and \"workflow\" events.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.Timespan"
            },
            "type": "array"
          },
          "timestamp": {
            "description": "Timestamp that the event occurred, as an RFC3339 timestamp.",
            "type": "string"
          },
          "type": {
            "description": "Type of the affected document.",
            "type": "string"
          },
          "updater_uri": {
            "description": "UpdaterUri is the URI for the subject that performed the update.",
            "type": "string"
          },
          "uuid": {
            "description": "Uuid of the document that was affected.",
            "type": "string"
          },
          "version": {
            "description": "Version of the document.",
            "type": "integer"
          },
          "workflow_checkpoint": {
            "description": "WorkflowCheckpoint that the document reached most recently.",
            "type": "string"
          },
          "workflow_state": {
            "description": "WorkflowState that the document is in.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.ExtendLockRequest": {
        "properties": {
          "token": {
            "description": "Lock token in UUID format.",
            "type": "string"
          },
          "ttl": {
            "description": "Lock TTL in milliseconds.",
            "type": "integer"
          },
          "uuid": {
            "description": "UUID of the document to extend the lock for.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.FilterOperator": {
        "enum": [
          "FILTER_OP_UNKNOWN",
          "FILTER_OP_ANY",
          "FILTER_OP_ALL",
          "FILTER_OP_NONE"
        ],
        "type": "string"
      },
      "elephant.repository.FilterValues": {
        "properties": {
          "values": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetAllActiveSchemasRequest": {
        "properties": {
          "known": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Known schema versions that the client already has. Optional.",
            "type": "object"
          },
          "only_changed": {
            "description": "OnlyChanged only returns the schemas that have been changed.",
            "type": "boolean"
          },
          "wait_seconds": {
            "description": "WaitSeconds is the maximum number of seconds to wait for changes, defaults to 10 seconds. Optional.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetAllActiveSchemasResponse": {
        "properties": {
          "removed": {
            "description": "Removed schemas.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "schemas": {
            "description": "Schemas that currently are active.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.Schema"
            },
            "type": "array"
          },
          "unchanged": {
            "description": "Unchanged is set to true if no changes were done compared to known schema versions.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetAttachmentsRequest": {
        "properties": {
          "attachment_name": {
            "description": "Attachment name to get information for.",
            "type": "string"
          },
          "documents": {
            "description": "Documents to get attachments for.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "download_link": {
            "description": "DownloadLink should be set to true to generate a download link.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetAttachmentsResponse": {
        "properties": {
          "attachments": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.AttachmentDetails"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetCompactedEventlogRequest": {
        "properties": {
          "after": {
            "description": "After specifies the event ID after which to start returning events.",
            "type": "integer"
          },
          "limit": {
            "description": "Limit restricts the number of events we want returned for each call. Together with `offset` this allows us to page through the unique document events between `after` and `until`. Defaults to 0, meaning no limit.",
            "type": "integer"
          },
          "offset": {
            "description": "Offset allows us to skip N number of events relative to `after`. So while `after` and until allows us to paginate through the log as a whole, `offset` and `limit` allows us to page through the unique document events between `after` and `until`. Defaults to 0, meaning no offset.",
            "type": "integer"
          },
          "type": {
            "description": "Type is used to only return events for documents of the given type. Defaults to empty, which will return events for all document types.",
            "type": "string"
          },
          "until": {
            "description": "Until allows us to control the number of events we want to evaluate when compacting. Must be between 1 and 10000 more than `after`, and cannot be greater than the current last event.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetCompactedEventlogResponse": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.EventlogItem"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetDeliverableInfoRequest": {
        "properties": {
          "uuid": {
            "description": "UUID of the deliverable.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetDeliverableInfoResponse": {
        "properties": {
          "assignment_uuid": {
            "description": "UUID of the related assignment.",
            "type": "string"
          },
          "event_uuid": {
            "description": "UUID of the related event.",
            "type": "string"
          },
          "has_planning_info": {
            "description": "Indicates whether the deliverable has planning information.",
            "type": "boolean"
          },
          "planning_uuid": {
            "description": "UUID of the related planning item.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetDeprecationsRequest": {
        "type": "object"
      },
      "elephant.repository.GetDeprecationsResponse": {
        "properties": {
          "deprecations": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.Deprecation"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetDocumentRequest": {
        "properties": {
          "lock": {
            "description": "Lock will lock the document for updates. This only affects the creation of new versions of the document, statuses can still be updated.",
            "type": "boolean"
          },
          "meta_document": {
            "$ref": "#/components/schemas/elephant.repository.GetMetaDoc"
          },
          "meta_document_version": {
            "description": "MetaDocumentVersion is used to fetch a specific version of meta document. Can not be used with status. If status is specified, the version the meta document had at the time the status was set is returned. If ommited and status is not used, the latest meta document version is returned.",
            "type": "integer"
          },
          "status": {
            "description": "Status is used to fetch the version of the document references by the last status update. Can be used instead of specifying a version.",
            "type": "string"
          },
          "uuid": {
            "description": "UUID of the document to get.",
            "type": "string"
          },
          "version": {
            "description": "Version to get, omit to get latest (or use status).",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetDocumentResponse": {
        "properties": {
          "document": {
            "$ref": "#/components/schemas/newsdoc.Document"
          },
          "is_meta_document": {
            "description": "IsMetaDocument is true if the document is a meta document.",
            "type": "boolean"
          },
          "main_document": {
            "description": "MainDocument is the UUID of the main document if this is a meta document.",
            "type": "string"
          },
          "meta": {
            "$ref": "#/components/schemas/elephant.repository.MetaDocument"
          },
          "status": {
            "$ref": "#/components/schemas/elephant.repository.Status"
          },
          "version": {
            "description": "Version is the version of the returned document.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetDocumentTypesRequest": {
        "type": "object"
      },
      "elephant.repository.GetDocumentTypesResponse": {
        "properties": {
          "types": {
            "description": "Types that have been defined in the schema.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetEventlogRequest": {
        "properties": {
          "after": {
            "description": "After specifies the event ID after which to start returning events. A negative value of -N will start from the N most recent events.",
            "type": "integer"
          },
          "batch_size": {
            "description": "BatchSize is the number of events we want in the response. Defaults to 10.",
            "type": "integer"
          },
          "batch_wait_ms": {
            "description": "BatchWaitMs is the maximum time we wait for a batch to be filled. Defaults to 200.",
            "type": "integer"
          },
          "wait_ms": {
            "description": "Wait is the maximum time to wait for new events. Defaults to 2000.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetEventlogResponse": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.EventlogItem"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetHistoryRequest": {
        "properties": {
          "before": {
            "description": "Before is which version number we should start fetching history from, omit to start with the latest version.",
            "type": "integer"
          },
          "load_statuses": {
            "description": "LoadStatuses loads any statuses set on the document versions.",
            "type": "boolean"
          },
          "uuid": {
            "description": "UUID of the document to get the history for.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetHistoryResponse": {
        "properties": {
          "versions": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.DocumentVersion"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetMatchingRequest": {
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/elephant.repository.DocumentFilter"
          },
          "include_documents": {
            "description": "IncludeDocuments should be set to true to get the document for each match.",
            "type": "boolean"
          },
          "include_meta": {
            "description": "IncludeMeta should be set to true to include document meta.",
            "type": "boolean"
          },
          "timespan": {
            "$ref": "#/components/schemas/elephant.repository.Timespan"
          },
          "type": {
            "description": "Type of the documents to get.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetMatchingResponse": {
        "properties": {
          "matches": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.DocumentMatch"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetMetaDoc": {
        "enum": [
          "META_NONE",
          "META_INCLUDE",
          "META_ONLY"
        ],
        "type": "string"
      },
      "elephant.repository.GetMetaRequest": {
        "properties": {
          "uuid": {
            "description": "UUID of the document to get metadata for",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetMetaResponse": {
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/elephant.repository.DocumentMeta"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetMetaTypesRequest": {
        "type": "object"
      },
      "elephant.repository.GetMetaTypesResponse": {
        "properties": {
          "types": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.MetaTypeInfo"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetMetricKindsRequest": {
        "type": "object"
      },
      "elephant.repository.GetMetricKindsResponse": {
        "properties": {
          "kinds": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.MetricKind"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetMetricsRequest": {
        "properties": {
          "kinds": {
            "description": "The metric kinds to get. Optional, defaults to all.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "uuids": {
            "description": "The documents to get metrics for.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetMetricsResponse": {
        "properties": {
          "documents": {
            "additionalProperties": {
              "$ref": "#/components/schemas/elephant.repository.DocumentMetrics"
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetNilStatusesRequest": {
        "properties": {
          "names": {
            "description": "Names of statuses to get, optional. Defaults to all statuses.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "uuid": {
            "description": "UUID of the document to get the nil statuses for.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetNilStatusesResponse": {
        "properties": {
          "statuses": {
            "additionalProperties": {
              "$ref": "#/components/schemas/elephant.repository.DocumentStatuses"
            },
            "type": "object"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetPermissionsRequest": {
        "properties": {
          "uuid": {
            "description": "UUID of the document to get the permissions for.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetPermissionsResponse": {
        "properties": {
          "permissions": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Permissions that the client has for the document. The map is keyed by the permission the client has and the value is either the client subject, the unit URI if the permission was granted through a unit membership, or \"scope://[name]\" if it was granted through elevated privileges.",
            "type": "object"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetSchemaRequest": {
        "properties": {
          "name": {
            "description": "Name of the schema to get.",
            "type": "string"
          },
          "version": {
            "description": "Version of the schema to get, optional. The currently active version of the schema will be returned if no version is specified.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetSchemaResponse": {
        "properties": {
          "spec": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetSocketTokenRequest": {
        "type": "object"
      },
      "elephant.repository.GetSocketTokenResponse": {
        "properties": {
          "token": {
            "description": "Token that is unique for the calling user that can be used to open websocket API connections.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetStatusHistoryReponse": {
        "properties": {
          "statuses": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.Status"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetStatusHistoryRequest": {
        "properties": {
          "before": {
            "description": "Before is a status ID used to page backwards through the status history. If no ID or a zero ID is provided the list will start with the lastest status.",
            "type": "integer"
          },
          "name": {
            "description": "Name of the status to get.",
            "type": "string"
          },
          "uuid": {
            "description": "UUID of the document to get the status history for.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetStatusOverviewRequest": {
        "properties": {
          "get_meta": {
            "description": "GetMeta can be used to load any set status metadata.",
            "type": "boolean"
          },
          "statuses": {
            "description": "Statuses to return information for. Optional, omit to only return workflow state.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "uuids": {
            "description": "UUIDs to get statuses for.",
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetStatusOverviewResponse": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.StatusOverviewItem"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetStatusRequest": {
        "properties": {
          "id": {
            "description": "ID of the status to get. Optional, will default to the latest status.",
            "type": "integer"
          },
          "name": {
            "description": "Name of the status to get.",
            "type": "string"
          },
          "uuid": {
            "description": "UUID of the document to get the status history for.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetStatusResponse": {
        "properties": {
          "status": {
            "$ref": "#/components/schemas/elephant.repository.Status"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetStatusRulesRequest": {
        "type": "object"
      },
      "elephant.repository.GetStatusRulesResponse": {
        "properties": {
          "rules": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.StatusRule"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetStatusesRequest": {
        "properties": {
          "type": {
            "description": "Type of documents to get statuses from.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetStatusesResponse": {
        "properties": {
          "statuses": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.WorkflowStatus"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetTypeConfigurationRequest": {
        "properties": {
          "type": {
            "description": "Type to get configuration for.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetTypeConfigurationResponse": {
        "properties": {
          "configuration": {
            "$ref": "#/components/schemas/elephant.repository.TypeConfiguration"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetWithheldRequest": {
        "type": "object"
      },
      "elephant.repository.GetWithheldResponse": {
        "properties": {
          "items": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.ScheduledDocument"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetWorkflowRequest": {
        "properties": {
          "type": {
            "description": "Type of the document to get workflow for.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.GetWorkflowResponse": {
        "properties": {
          "updated": {
            "description": "Updated is the update time as a RFC3339 timestamp.",
            "type": "string"
          },
          "updater_uri": {
            "description": "UpdaterURI identifies the user that last updated the workflow.",
            "type": "string"
          },
          "workflow": {
            "$ref": "#/components/schemas/elephant.repository.DocumentWorkflow"
          }
        },
        "type": "object"
      },
      "elephant.repository.ImportDirective": {
        "description": "ImportDirective can be used to preserve timestamps and authorship information from originating systems.",
        "properties": {
          "original_creator": {
            "type": "string"
          },
          "originally_created": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.ListActiveSchemasRequest": {
        "type": "object"
      },
      "elephant.repository.ListActiveSchemasResponse": {
        "properties": {
          "schemas": {
            "description": "Schemas without the spec populated",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.Schema"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.ListDeletedRequest": {
        "properties": {
          "before_date": {
            "description": "BeforeDate is used to get deletions going back from before the specified date YYYY-MM-DD. Optional, will be ignored if before_id is specified.",
            "type": "string"
          },
          "before_id": {
            "description": "BeforeID is used to paginate backwards in deletions. Optional.",
            "type": "integer"
          },
          "timezone": {
            "description": "Timezone that the date should be interpreted in.",
            "type": "string"
          },
          "uuid": {
            "description": "UUID of the document list deletions of. Optional.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.ListDeletedResponse": {
        "properties": {
          "deletes": {
            "description": "Deletes that have been performed on document instances with the given UUID.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.DeleteRecord"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.Lock": {
        "properties": {
          "app": {
            "description": "URI identifying the locking application.",
            "type": "string"
          },
          "comment": {
            "description": "Optional free-form comment.",
            "type": "string"
          },
          "created": {
            "description": "Created timestamp is the RFC3339 timestamp for when the lock was created.",
            "type": "string"
          },
          "expires": {
            "description": "Expires timestamp is the RFC3339 timestamp for when the lock will expire.",
            "type": "string"
          },
          "token": {
            "description": "Lock token string",
            "type": "string"
          },
          "uri": {
            "description": "URI of the lock owner",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.LockRequest": {
        "properties": {
          "app": {
            "description": "Name of the locking application. Optional.",
            "type": "string"
          },
          "comment": {
            "description": "Free-form comment string. Optional.",
            "type": "string"
          },
          "ttl": {
            "description": "Lock TTL in milliseconds",
            "type": "integer"
          },
          "uuid": {
            "description": "UUID of the document to lock",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.LockResponse": {
        "properties": {
          "expires": {
            "description": "Expires is the RFC3339 timestamp when the lock will expire.",
            "type": "string"
          },
          "token": {
            "description": "Generated lock token in UUID format.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.MetaDocument": {
        "properties": {
          "document": {
            "$ref": "#/components/schemas/newsdoc.Document"
          },
          "version": {
            "description": "Version is the version of the returned document.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.MetaTypeInfo": {
        "properties": {
          "name": {
            "type": "string"
          },
          "used_by": {
            "items": {
              "type": "string"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.Metric": {
        "properties": {
          "kind": {
            "type": "string"
          },
          "label": {
            "type": "string"
          },
          "value": {
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.MetricAggregation": {
        "enum": [
          "NONE",
          "REPLACE",
          "INCREMENT"
        ],
        "type": "string"
      },
      "elephant.repository.MetricKind": {
        "properties": {
          "aggregation": {
            "$ref": "#/components/schemas/elephant.repository.MetricAggregation"
          },
          "name": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.PurgeRequest": {
        "properties": {
          "delete_record_id": {
            "description": "DeleteRecordID for the specific instance of the document that should be purged.",
            "type": "integer"
          },
          "uuid": {
            "description": "UUID of the document to purge.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.PurgeResponse": {
        "type": "object"
      },
      "elephant.repository.RegisterMetaTypeRequest": {
        "properties": {
          "exclusive": {
            "description": "Exclusive - set to true to only allow the type to be used as a meta type.",
            "type": "boolean"
          },
          "type": {
            "description": "Type to use as a meta type.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.RegisterMetaTypeResponse": {
        "type": "object"
      },
      "elephant.repository.RegisterMetaTypeUseRequest": {
        "properties": {
          "main_type": {
            "description": "MainType to use the meta type for.",
            "type": "string"
          },
          "meta_type": {
            "description": "MetaType to use for the main document.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.RegisterMetaTypeUseResponse": {
        "type": "object"
      },
      "elephant.repository.RegisterMetricKindRequest": {
        "properties": {
          "aggregation": {
            "$ref": "#/components/schemas/elephant.repository.MetricAggregation"
          },
          "name": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.RegisterMetricKindResponse": {
        "type": "object"
      },
      "elephant.repository.RegisterMetricRequest": {
        "properties": {
          "kind": {
            "type": "string"
          },
          "label": {
            "type": "string"
          },
          "uuid": {
            "type": "string"
          },
          "value": {
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.RegisterMetricResponse": {
        "type": "object"
      },
      "elephant.repository.RegisterSchemaRequest": {
        "properties": {
          "activate": {
            "description": "Activate the registered schema immediately.",
            "type": "boolean"
          },
          "schema": {
            "$ref": "#/components/schemas/elephant.repository.Schema"
          },
          "schema_sha256": {
            "description": "SchemaSHA256 is a SHA256 checksum to validate the response body from the schema URL against.",
            "type": "string"
          },
          "schema_url": {
            "description": "SchemaURL is an HTTP(S) url to the schema to load, can be passed instead of an inline schema spec.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.RegisterSchemaResponse": {
        "type": "object"
      },
      "elephant.repository.RestoreRequest": {
        "properties": {
          "acl": {
            "description": "ACL that should be set for the restored document.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.ACLEntry"
            },
            "type": "array"
          },
          "delete_record_id": {
            "description": "DeleteRecordID for the specific instance of the document that was deleted.",
            "type": "integer"
          },
          "uuid": {
            "description": "UUID of the document to restore.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.RestoreResponse": {
        "type": "object"
      },
      "elephant.repository.ScheduledDocument": {
        "properties": {
          "assignment": {
            "description": "Assignment ID.",
            "type": "string"
          },
          "document_version": {
            "description": "DocumentVersion is the last version that was set as withheld.",
            "type": "integer"
          },
          "planning_item": {
            "description": "PlanningItem UUID.",
            "type": "string"
          },
          "publish": {
            "description": "Publish timestamp as RFC3339 set in the assignment.",
            "type": "string"
          },
          "scheduled_by": {
            "description": "ScheduledBy is the sub of the user that set the withheld status.",
            "type": "string"
          },
          "status_id": {
            "description": "StatusID is the last withheld status ID.",
            "type": "integer"
          },
          "type": {
            "description": "Type of the scheduled document.",
            "type": "string"
          },
          "uuid": {
            "description": "UUID is the ID of the scheduled document.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.Schema": {
        "properties": {
          "name": {
            "type": "string"
          },
          "spec": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.SetActiveSchemaRequest": {
        "properties": {
          "deactivate": {
            "description": "Deactivate is used to disable a schema, activate new schema versions instead if you want to start using a new version.",
            "type": "boolean"
          },
          "name": {
            "description": "Name is the name of the schema to activate or deactivate, required.",
            "type": "string"
          },
          "version": {
            "description": "Version of the schema to activate, required when activating a new version.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.SetActiveSchemaResponse": {
        "type": "object"
      },
      "elephant.repository.SetWorkflowRequest": {
        "properties": {
          "type": {
            "description": "Type of the document that this workflow is for.",
            "type": "string"
          },
          "workflow": {
            "$ref": "#/components/schemas/elephant.repository.DocumentWorkflow"
          }
        },
        "type": "object"
      },
      "elephant.repository.SetWorkflowResponse": {
        "type": "object"
      },
      "elephant.repository.Status": {
        "properties": {
          "created": {
            "description": "Created timestamp is the RFC3339 timestamp for when the status was created.",
            "type": "string"
          },
          "creator": {
            "description": "Creator of the status.",
            "type": "string"
          },
          "id": {
            "description": "ID of the status.",
            "type": "integer"
          },
          "meta": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Meta data for the status.",
            "type": "object"
          },
          "meta_doc_version": {
            "description": "MetaDocumentVersion is the version the meta document had at the time the status was set.",
            "type": "integer"
          },
          "version": {
            "description": "Version of the document that the status refers to.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.StatusOverviewItem": {
        "properties": {
          "creator_uri": {
            "description": "CreatorURI is the URI of the subject that created the document.",
            "type": "string"
          },
          "heads": {
            "additionalProperties": {
              "$ref": "#/components/schemas/elephant.repository.Status"
            },
            "description": "Heads are the last statuses.",
            "type": "object"
          },
          "modified": {
            "description": "Modified timestamp is the RFC3339 timestamp for the last change that affected the document.",
            "type": "string"
          },
          "updater_uri": {
            "description": "UpdaterURI is the URI of the subject that last updated the document.",
            "type": "string"
          },
          "uuid": {
            "description": "UUID of the document.",
            "type": "string"
          },
          "version": {
            "description": "Version is the current version (last written version) of the document.",
            "type": "integer"
          },
          "workflow_checkpoint": {
            "description": "WorkflowCheckpoint that the document reached most recently.",
            "type": "string"
          },
          "workflow_state": {
            "description": "WorkflowState that the document is in.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.StatusRule": {
        "properties": {
          "access_rule": {
            "description": "AccessRule whether this rule acts as access control.",
            "type": "boolean"
          },
          "applies_to": {
            "description": "AppliesTo is a list of statuses that this rule applies to.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "description": {
            "description": "Description of the rule.",
            "type": "string"
          },
          "expression": {
            "description": "Expression that is evaluated for the rule.",
            "type": "string"
          },
          "name": {
            "description": "Name of the rule.",
            "type": "string"
          },
          "type": {
            "description": "Type that the status rule applies to.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.StatusUpdate": {
        "properties": {
          "if_match": {
            "description": "IfMatch is used for optimistic locks. Set to the status id that you require to be the current one for the status to be set, or -1 to only perform the update if the status hasn't previously been set.",
            "type": "integer"
          },
          "meta": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Meta data to include with the status update.",
            "type": "object"
          },
          "name": {
            "description": "Name of the status to set.",
            "type": "string"
          },
          "version": {
            "description": "Version to set the status for. Set to -1 to signal that the status no longer is valid for the document. Optional if part of a document update request as it then will default to the version being written.",
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.Timespan": {
        "properties": {
          "from": {
            "type": "string"
          },
          "to": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.TypeConfiguration": {
        "properties": {
          "bounded_collection": {
            "description": "Set to true if this is a collection of documents that are bounded (limited in size). Bounded collections can be fetched by type and language in one go.",
            "type": "boolean"
          },
          "time_expressions": {
            "description": "TimeExpressions are used for extracting time ranges from documents.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.TypeTimeExpression"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.TypeTimeExpression": {
        "properties": {
          "expression": {
            "description": "Expression is a newsdoc value extraction expression.",
            "type": "string"
          },
          "layout": {
            "description": "Layout is the time/date format to use when parsing. Optional, defaults to RFC3339 or ISO 8601 for values annotated as dates.",
            "type": "string"
          },
          "timezone": {
            "description": "Timezone is the timezone the time should be parsed in. Optional, most timestamps should include timezone information, if they don't, parsing will fall back to the default timezone that the repository has been configured with.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.UnlockRequest": {
        "properties": {
          "token": {
            "description": "Lock token in UUID format.",
            "type": "string"
          },
          "uuid": {
            "description": "UUID of the document to unlock",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.UnlockResponse": {
        "type": "object"
      },
      "elephant.repository.UpdateDeprecationRequest": {
        "properties": {
          "deprecation": {
            "$ref": "#/components/schemas/elephant.repository.Deprecation"
          }
        },
        "type": "object"
      },
      "elephant.repository.UpdateDeprecationResponse": {
        "type": "object"
      },
      "elephant.repository.UpdatePermissionsRequest": {
        "properties": {
          "list": {
            "description": "Set (upsert based on URI) this list of ACL entries.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.ACLEntry"
            },
            "type": "array"
          },
          "uuid": {
            "description": "UUID of the document to update permissions for.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.UpdatePermissionsResponse": {
        "type": "object"
      },
      "elephant.repository.UpdateRequest": {
        "description": "UpdateRequest creates a new document version and/or sets statuses and ACLs for a document. The update is transactional will fail or succed as a whole.\n If the document fails validation an \"invalid_argument\" error will be returned with the number of errors as meta \"err_count\" and the individual errors as \"0\", \"1\", \"2\"... Use the Validate method to get th errors as structured data.",
        "properties": {
          "acl": {
            "description": "ACL is an ACL list controlling access to the document.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.ACLEntry"
            },
            "type": "array"
          },
          "attach_objects": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "AttachObjects is used to attach uploaded objects to a document. This must be done in combination with a document create or update. The key is the object name, f.ex. \"image\" or \"audio\", and the value is an upload ID. See CreateUpload().",
            "type": "object"
          },
          "detach_objects": {
            "description": "DetatchObjects is used to detach uploaded objects from a document. This must be done in combination with a document create or update.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "document": {
            "$ref": "#/components/schemas/newsdoc.Document"
          },
          "if_match": {
            "description": "IfMatch is used for optimistic locks. Set to the version that you require to be the current one for the update to be performed, or -1 to only perform the update if the document doesn't already exist.",
            "type": "integer"
          },
          "if_status_heads": {
            "additionalProperties": {
              "type": "integer"
            },
            "description": "IfStatusHeads is used to only perform the update if the status heads match.",
            "type": "object"
          },
          "if_workflow_state": {
            "description": "IfWorkflowState is used to only perform the update if it's in the specified workflow state.",
            "type": "string"
          },
          "import_directive": {
            "$ref": "#/components/schemas/elephant.repository.ImportDirective"
          },
          "lockToken": {
            "description": "LockToken is used for explicit pessimistic locking.",
            "type": "string"
          },
          "meta": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Meta data to associate with the document version.",
            "type": "object"
          },
          "status": {
            "description": "Status updates to perform.",
            "items": {
              "$ref": "#/components/schemas/elephant.repository.StatusUpdate"
            },
            "type": "array"
          },
          "update_meta_document": {
            "description": "UpdateMetaDocument can be set to true to update the meta document instead of the document identified by the UUID.",
            "type": "boolean"
          },
          "uuid": {
            "description": "UUID of the document to update.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.UpdateResponse": {
        "description": "UpdateResponse describes the result of an update request.",
        "properties": {
          "uuid": {
            "type": "string"
          },
          "version": {
            "type": "integer"
          }
        },
        "type": "object"
      },
      "elephant.repository.UpdateStatusRequest": {
        "properties": {
          "disabled": {
            "description": "Disabled disables the status so that it cannot be used when setting new statuses.",
            "type": "boolean"
          },
          "name": {
            "description": "Name of the status.",
            "type": "string"
          },
          "type": {
            "description": "Type that the status is valid for.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.UpdateStatusResponse": {
        "type": "object"
      },
      "elephant.repository.ValidateRequest": {
        "properties": {
          "document": {
            "$ref": "#/components/schemas/newsdoc.Document"
          }
        },
        "type": "object"
      },
      "elephant.repository.ValidateResponse": {
        "properties": {
          "errors": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.ValidationResult"
            },
            "type": "array"
          }
        },
        "type": "object"
      },
      "elephant.repository.ValidationResult": {
        "properties": {
          "entity": {
            "items": {
              "$ref": "#/components/schemas/elephant.repository.EntityRef"
            },
            "type": "array"
          },
          "error": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "elephant.repository.WorkflowStatus": {
        "properties": {
          "name": {
            "type": "string"
          },
          "type": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "newsdoc.Block": {
        "description": "Block is the building block for data embedded in documents. It is used for both content, links and metadata. Blocks have can be nested, but that's nothing to strive for, keep it simple.",
        "properties": {
          "content": {
            "description": "Content is used to embed content blocks.",
            "items": {
              "$ref": "#/components/schemas/newsdoc.Block"
            },
            "type": "array"
          },
          "contenttype": {
            "description": "ContentType is used to describe the content type of the block/linked entity if it differs from the type of the block.",
            "type": "string"
          },
          "data": {
            "additionalProperties": {
              "type": "string"
            },
            "description": "Data contains block data.",
            "type": "object"
          },
          "id": {
            "description": "ID is the block ID,",
            "type": "string"
          },
          "links": {
            "description": "Links are used to link to other resources and documents.",
            "items": {
              "$ref": "#/components/schemas/newsdoc.Block"
            },
            "type": "array"
          },
          "meta": {
            "description": "Meta is used to embed metadata",
            "items": {
              "$ref": "#/components/schemas/newsdoc.Block"
            },
            "type": "array"
          },
          "name": {
            "description": "Name is a name for the block. An alternative to \"rel\" when relationship is a term that doesn't fit.",
            "type": "string"
          },
          "rel": {
            "description": "Rel describes the relationship to the document/parent entity.",
            "type": "string"
          },
          "role": {
            "description": "Role is used either as an alternative to rel, or for nuancing the relationship.",
            "type": "string"
          },
          "sensitivity": {
            "description": "Sensitivity can be use to communicate how the information in a block can be handled. It could f.ex. be set to \"internal\", to show that it contains information that must be removed or transformed before publishing.",
            "type": "string"
          },
          "title": {
            "description": "Title is the title/headline of the block, typically used in the presentation of the block.",
            "type": "string"
          },
          "type": {
            "description": "Type is the type of the block",
            "type": "string"
          },
          "uri": {
            "description": "URI is used to reference another entity in a document.",
            "type": "string"
          },
          "url": {
            "description": "URL is a browseable URL for the the block.",
            "type": "string"
          },
          "uuid": {
            "description": "UUID is used to reference another Document in a block.",
            "type": "string"
          },
          "value": {
            "description": "Value is a value for the block. Useful when we want to store a primitive value.",
            "type": "string"
          }
        },
        "type": "object"
      },
      "newsdoc.Document": {
        "description": "Document is a NewsDoc document.",
        "properties": {
          "content": {
            "description": "Content is the content of the document, this is essentially what gets rendered on the page when you view a document.",
            "items": {
              "$ref": "#/components/schemas/newsdoc.Block"
            },
            "type": "array"
          },
          "language": {
            "description": "Language is the language used in the document as an IETF language tag. F.ex. \"en\", \"en-UK\", \"es\", or \"sv-SE\".",
            "type": "string"
          },
          "links": {
            "description": "Links are links to other resources and entities. This could be links to topics, categories and subjects for the document, or credited authors.",
            "items": {
              "$ref": "#/components/schemas/newsdoc.Block"
            },
            "type": "array"
          },
          "meta": {
            "description": "Meta is the metadata for a document, this could be things like teasers, open graph data, newsvalues.",
            "items": {
              "$ref": "#/components/schemas/newsdoc.Block"
            },
            "type": "array"
          },
          "title": {
            "description": "Title is the title of the document, can be used as the document name, or the headline when the document is displayed.",
            "type": "string"
          },
          "type": {
            "description": "Type is the content type of the document.",
            "type": "string"
          },
          "uri": {
            "description": "URI identifies the document (in a more human-readable way than the UUID).",
            "type": "string"
          },
          "url": {
            "description": "URL is the browseable location of the document (if any).",
            "type": "string"
          },
          "uuid": {
            "description": "UUID is a unique ID for the document, this can for example be a random v4 UUID, or a URI-derived v5 UUID.",
            "type": "string"
          }
        },
        "type": "object"
      }
    },
    "securitySchemes": {
      "bearer": {
        "bearerFormat": "JWT",
        "scheme": "bearer",
        "type": "http"
      }
    }
  },
  "info": {
    "title": "repository API",
    "version": "v0.19.0"
  },
  "openapi": "3.0.0",
  "paths": {
    "/twirp/elephant.repository.Documents/BulkGet": {
      "post": {
        "description": "BulkGet loads multiple documents in a single request.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.BulkGetRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.BulkGetResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "BulkGet",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/BulkUpdate": {
      "post": {
        "description": "BulkUpdate is used to create new document versions, set statuses, update ACLs.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.BulkUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.BulkUpdateResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "BulkUpdate",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/CompactedEventlog": {
      "post": {
        "description": "CompactedEventlog returns document update events. If more than one event has occured for a document in the given window only the latest will be returned.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetCompactedEventlogRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetCompactedEventlogResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "CompactedEventlog",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/CreateUpload": {
      "post": {
        "description": "CreateUpload is used to start the process of uploading objects that then can be attached to a document.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.CreateUploadRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.CreateUploadResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "CreateUpload",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/Delete": {
      "post": {
        "description": "Delete deletes a document and all its associated data.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.DeleteDocumentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.DeleteDocumentResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Delete",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/Eventlog": {
      "post": {
        "description": "Eventlog returns document update events, optionally waiting for new events.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetEventlogRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetEventlogResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Eventlog",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/ExtendLock": {
      "post": {
        "description": "ExtendLock extends the expiration of an existing lock.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.ExtendLockRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.LockResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "ExtendLock",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/Get": {
      "post": {
        "description": "Get retrieves a document version.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetDocumentRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetDocumentResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Get",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/GetAttachments": {
      "post": {
        "description": "GetAttachments returns download links for the requested attachments.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetAttachmentsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetAttachmentsResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetAttachments",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/GetDeliverableInfo": {
      "post": {
        "description": "GetDeliverableInfo returns available information related to the deliverable.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetDeliverableInfoRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetDeliverableInfoResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetDeliverableInfo",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/GetHistory": {
      "post": {
        "description": "GetHistory lists the document version history.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetHistoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetHistoryResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetHistory",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/GetMatching": {
      "post": {
        "description": "GetMatching returns documents matching the given criteria.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetMatchingRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetMatchingResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetMatching",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/GetMeta": {
      "post": {
        "description": "GetMeta returns metadata for a document, including the ACL and current status heads.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetMetaRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetMetaResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetMeta",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/GetNilStatuses": {
      "post": {
        "description": "GetNilStatuses returns all the statuses for a document where version is -1.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetNilStatusesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetNilStatusesResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetNilStatuses",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/GetPermissions": {
      "post": {
        "description": "GetPermissions returns the permissions you have for the document.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetPermissionsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetPermissionsResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetPermissions",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/GetSocketToken": {
      "post": {
        "description": "GetSocketToken returns a token that can be used to open socket connections.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetSocketTokenRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetSocketTokenResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetSocketToken",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/GetStatus": {
      "post": {
        "description": "GetStatus returns a single status for a document.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetStatusResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetStatus",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/GetStatusHistory": {
      "post": {
        "description": "GetStatusHistory returns the history of a status for a document.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetStatusHistoryRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetStatusHistoryReponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetStatusHistory",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/GetStatusOverview": {
      "post": {
        "description": "GetStatusOverview returns the current version and a set of statuses for a gven list of documents.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetStatusOverviewRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetStatusOverviewResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetStatusOverview",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/GetWithheld": {
      "post": {
        "description": "GetWithheld returns the next upcoming scheduled publish actions. This is not a complete list, but a list of the next N documents that are considered eligible for publishing.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetWithheldRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetWithheldResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetWithheld",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/ListDeleted": {
      "post": {
        "description": "ListDeleted lists deleted document instances for a UUID.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.ListDeletedRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.ListDeletedResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "ListDeleted",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/Lock": {
      "post": {
        "description": "Lock attempts to acquire a write lock on a document.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.LockRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.LockResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Lock",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/Purge": {
      "post": {
        "description": "Purge removes a deleted document completely.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.PurgeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.PurgeResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Purge",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/Restore": {
      "post": {
        "description": "Restore recovers a deleted document.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.RestoreRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.RestoreResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Restore",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/Unlock": {
      "post": {
        "description": "Unlock releases a write lock on a document.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.UnlockRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.UnlockResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Unlock",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/Update": {
      "post": {
        "description": "Update is used to create new document versions, set statuses, update ACLs.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.UpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.UpdateResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Update",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Documents/Validate": {
      "post": {
        "description": "Validate is used to validate a document without writing it to the repository.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.ValidateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.ValidateResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Validate",
        "tags": [
          "Documents"
        ]
      }
    },
    "/twirp/elephant.repository.Metrics/DeleteKind": {
      "post": {
        "description": "Delete a metric kind",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.DeleteMetricKindRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.DeleteMetricKindResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "DeleteKind",
        "tags": [
          "Metrics"
        ]
      }
    },
    "/twirp/elephant.repository.Metrics/GetKinds": {
      "post": {
        "description": "List all metric kinds",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetMetricKindsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetMetricKindsResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetKinds",
        "tags": [
          "Metrics"
        ]
      }
    },
    "/twirp/elephant.repository.Metrics/GetMetrics": {
      "post": {
        "description": "GetMetrics returns metrics related to a document.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetMetricsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetMetricsResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetMetrics",
        "tags": [
          "Metrics"
        ]
      }
    },
    "/twirp/elephant.repository.Metrics/RegisterKind": {
      "post": {
        "description": "Register a metric kind",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.RegisterMetricKindRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.RegisterMetricKindResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "RegisterKind",
        "tags": [
          "Metrics"
        ]
      }
    },
    "/twirp/elephant.repository.Metrics/RegisterMetric": {
      "post": {
        "description": "Register a data point",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.RegisterMetricRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.RegisterMetricResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "RegisterMetric",
        "tags": [
          "Metrics"
        ]
      }
    },
    "/twirp/elephant.repository.Schemas/ConfigureType": {
      "post": {
        "description": "ConfigureType configures a document type.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.ConfigureTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.ConfigureTypeResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "ConfigureType",
        "tags": [
          "Schemas"
        ]
      }
    },
    "/twirp/elephant.repository.Schemas/Get": {
      "post": {
        "description": "Get retrieves a schema.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetSchemaRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetSchemaResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Get",
        "tags": [
          "Schemas"
        ]
      }
    },
    "/twirp/elephant.repository.Schemas/GetAllActive": {
      "post": {
        "description": "GetAllActiveSchemas returns the currently active schemas.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetAllActiveSchemasRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetAllActiveSchemasResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetAllActive",
        "tags": [
          "Schemas"
        ]
      }
    },
    "/twirp/elephant.repository.Schemas/GetDeprecations": {
      "post": {
        "description": "GetDeprecations lists all deprecations.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetDeprecationsRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetDeprecationsResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetDeprecations",
        "tags": [
          "Schemas"
        ]
      }
    },
    "/twirp/elephant.repository.Schemas/GetDocumentTypes": {
      "post": {
        "description": "GetDocumentTypes lists the defined document types.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetDocumentTypesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetDocumentTypesResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetDocumentTypes",
        "tags": [
          "Schemas"
        ]
      }
    },
    "/twirp/elephant.repository.Schemas/GetMetaTypes": {
      "post": {
        "description": "GetMetaTypes lists the registered meta types.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetMetaTypesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetMetaTypesResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetMetaTypes",
        "tags": [
          "Schemas"
        ]
      }
    },
    "/twirp/elephant.repository.Schemas/GetTypeConfiguration": {
      "post": {
        "description": "GetTypeConfiguration returns the current configuration for a type.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetTypeConfigurationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetTypeConfigurationResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetTypeConfiguration",
        "tags": [
          "Schemas"
        ]
      }
    },
    "/twirp/elephant.repository.Schemas/ListActive": {
      "post": {
        "description": "ListActiveSchemas lists the currently active schemas.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.ListActiveSchemasRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.ListActiveSchemasResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "ListActive",
        "tags": [
          "Schemas"
        ]
      }
    },
    "/twirp/elephant.repository.Schemas/Register": {
      "post": {
        "description": "Register register a new validation schema version.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.RegisterSchemaRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.RegisterSchemaResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "Register",
        "tags": [
          "Schemas"
        ]
      }
    },
    "/twirp/elephant.repository.Schemas/RegisterMetaType": {
      "post": {
        "description": "RegisterMetaType registers a type that can be used for meta documents.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.RegisterMetaTypeRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.RegisterMetaTypeResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "RegisterMetaType",
        "tags": [
          "Schemas"
        ]
      }
    },
    "/twirp/elephant.repository.Schemas/RegisterMetaTypeUse": {
      "post": {
        "description": "RegisterMetaTypeUse registers a meta type for use with a main type.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.RegisterMetaTypeUseRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.RegisterMetaTypeUseResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "RegisterMetaTypeUse",
        "tags": [
          "Schemas"
        ]
      }
    },
    "/twirp/elephant.repository.Schemas/SetActive": {
      "post": {
        "description": "SetActive activates schema versions.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.SetActiveSchemaRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.SetActiveSchemaResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "SetActive",
        "tags": [
          "Schemas"
        ]
      }
    },
    "/twirp/elephant.repository.Schemas/UpdateDeprecation": {
      "post": {
        "description": "UpdateDeprecation creates or updates a deprecation.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.UpdateDeprecationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.UpdateDeprecationResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "UpdateDeprecation",
        "tags": [
          "Schemas"
        ]
      }
    },
    "/twirp/elephant.repository.Workflows/CreateStatusRule": {
      "post": {
        "description": "CreateStatusRule creates or updates a status rule that should be applied when setting statuses.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.CreateStatusRuleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.CreateStatusRuleResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "CreateStatusRule",
        "tags": [
          "Workflows"
        ]
      }
    },
    "/twirp/elephant.repository.Workflows/DeleteStatusRule": {
      "post": {
        "description": "DeleteStatusRule removes a status rule.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.DeleteStatusRuleRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.DeleteStatusRuleResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "DeleteStatusRule",
        "tags": [
          "Workflows"
        ]
      }
    },
    "/twirp/elephant.repository.Workflows/DeleteWorkflow": {
      "post": {
        "description": "DeleteWorkflow removes the workflow configuration for a document type.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.DeleteWorkflowRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.DeleteWorkflowResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "DeleteWorkflow",
        "tags": [
          "Workflows"
        ]
      }
    },
    "/twirp/elephant.repository.Workflows/GetStatusRules": {
      "post": {
        "description": "GetStatusRules returns all status rules.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetStatusRulesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetStatusRulesResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetStatusRules",
        "tags": [
          "Workflows"
        ]
      }
    },
    "/twirp/elephant.repository.Workflows/GetStatuses": {
      "post": {
        "description": "GetStatuses lists all enabled statuses.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetStatusesRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetStatusesResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetStatuses",
        "tags": [
          "Workflows"
        ]
      }
    },
    "/twirp/elephant.repository.Workflows/GetWorkflow": {
      "post": {
        "description": "GetWorkflow for a document type.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.GetWorkflowRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.GetWorkflowResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "GetWorkflow",
        "tags": [
          "Workflows"
        ]
      }
    },
    "/twirp/elephant.repository.Workflows/SetWorkflow": {
      "post": {
        "description": "SetWorkflow configures a workflow for a document type.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.SetWorkflowRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.SetWorkflowResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "SetWorkflow",
        "tags": [
          "Workflows"
        ]
      }
    },
    "/twirp/elephant.repository.Workflows/UpdateStatus": {
      "post": {
        "description": "UpdateStatus creates or updates a status that can be used for documents.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/elephant.repository.UpdateStatusRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/elephant.repository.UpdateStatusResponse"
                }
              }
            },
            "description": "Method response"
          },
          "default": {
            "description": ""
          }
        },
        "security": [
          {
            "bearer": []
          }
        ],
        "summary": "UpdateStatus",
        "tags": [
          "Workflows"
        ]
      }
    }
  },
  "servers": [
    {
      "url": "https://repository.api.tt.se"
    },
    {
      "url": "https://repository.api.stage.tt.se"
    }
  ],
  "tags": [
    {
      "name": "Documents"
    },
    {
      "name": "Schemas"
    },
    {
      "name": "Workflows"
    },
    {
      "name": "Metrics"
    }
  ]
}